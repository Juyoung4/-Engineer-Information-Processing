### 4-1 서버 프로그램 구현
##### 개발 환경 구축하기
* 개발 환경 준비
    - 개발 환경 구축 이해: 해당 프로젝트의 목적 + 구축 설계에 대한 명확한 이해, HW/SW 선정, 제품들의 성능+라이선스+사용 편의성
        + 개발을 위해 사용되는 SW의 도구
            - 구현 도구: 가장 많이 사용되는 도구(코드의 작성 및 편집, 디버깅) | (ex) eclipse, visual studio code, IntelliJ, NetBeans 
            - 형상 관리 도구: 코드 및 리소스 등 산출물에 대한 버전 관리 도구 | (ex) CVS, Subversion, Git
            - 빌드 도구: 작성 코드 빌드 및 배포, 구성요소들과 라이브러리들에 대한 의존성 관리 도구 | (ex) Ant, Maven, Gradle
            - 테스트 도구: 품질을 높이기 위해 사용되는 도구(코드의 테스트, 테스트에 대한 리포팅/분석) | (ex) xUnit, Sprint Test
    
    - 개발 환경 준비 수행 순서
        1. 목표 시스템의 환경분석
            - 분석 및 설계의 산출물(ex_제안서, 요구사항 정의서, 아키텍처등)을 분석하여 개발 환경 준비
            - 개발 환경 구축에 필요한 도구 파악(언어, hw 등) -> 요구사항 분석(ex_기능, 성능, 품질, 보안 등)
        2. 구현 도구 선정(개발 언어, HW 사양 고려해서)
            - 개발 언어 선정 (ex_ server side 언어, client side 언어 각각 선정)
                * **개발 언어 선정 기준**: 적정성, 효율성, 이식성, 친밀성, 범용성(광범위하게 사용되고 있어야 함)
            - 개발 도구 선정(구현 도구 선정-통합 개발 환경 선정) => 풍부한 기능 + Plug-in 
            
                | 통합 개발 환경| 언어 |
                |:---:|---:|
                |eclipse|java,c,c++,python,php,jsp|
                |visual studio code|c,c#,dockerfile,go,html,php,typescript|
                |delphi|object pascal|
                |lazrus|pascal|
                |visual studio|Net, visual c#, visual c++|
                -나머지 나오면 C, C++이라고 생각하기
        3. 빌드 도구 선정(배포, 라이브러리 관리)
            - **3가지 선정 사항**
                
                    팀원의 빌드도구에 대한 친밀도+숙련도에 따라 결정
                    형상 관리 도구를 고려하여 선정
                    통합 개발 도구와 호환 가능한 도구 선정
        4. 형상 관리 도구 선정(개발 인원 고려)
            - 통합 개발 도구와 호환이 가능한 도구 선정
            - 목표 시스템 환경 고려
        5. 테스트 도구 선정(프로젝트 검증)
            - 테스트 계획 -> 도구(요구사항 관리)
            - 테스트 분석/설계 -> 도구(테스트 케이스 생성, 커버리지 분석)
            - 테스트 수행 -> 도구(테스트 자동화, 정적 분석, 동적 분석, 성능 테스트, 모니터링, 형상 관리, 테스트 관리, 결함/추적 관리)
            - 널리 사용되는 자동화도구 이용 & 통합 개발 도구와 호환되는지 확인
    
    - 개발 환경 구축
        + 개발환경 구축시 구성요소 = **HW 환경(웹 서버 환경 + 클라이언트 환경) + SW 환경(시스템 SW + 개발 SW)**
            - HW 환경
                - 운영환경과 유사한 구조로 구성
                - 클라이언트 환경: 사용자와의 인터페이스를 제공하는 HW (ex_ pc, 웹 브라우저, 핸드폰)
                - 서버 환경: 웹 서버(요청/응답 처리, 정적파일), 웹 애플리케이션 서버(동적 파일), 데이터베이스 서버, 파일 서버(물리적 저장 장치)
            - SW 환경
                - 운영환경과 유사한 구조로 구성
                - 시스템 SW: OS(HW운영을 위한), JVM(JAVA를 위한 인터프리터 환경), 웹 서버(미들웨어), WAS(미들웨어), DBMS
                - 개발 SW: 요구사항 관리도구, 설계/모니터링 도구(모델링 도구), 구현 도구, 형상 관리 도구
        + 형상 관리 구성
            * 형상 관리(SCM) = 기능적 특성, 물리적 특성을 문서화하고 그들의 특성의 변경을 관리, 변경의 과정-실현 상황 기록-보고
            - SW 개발의 전체 비용 줄이고, 문제점 발생 요인이 최소화하도록 보증
            - 형상 관리 절차(품질 보증) = 형상 식별->버전 제어->형상 통제(변경통제)->형상 감사->형상기록(상태보고)
            - 형상 항목: SW공학 기반(프로젝트 계획서, 요구사항 명세서, 아키텍처-실행가능 프로토타입, 화면, 프로그램 설계서), DB(소스코드, 실행 프로그램, 테스트 계획-절차-결과, 메뉴얼), 유지보수(변경 요청서, 처리 보고서)
            
--------------
##### 공통 모듈 구현하기
*  공통 모듈의 재사용
    * 재사용 = 검증된 기능을 파악하고 재구성하여 시스템에 응용하기 위한 최적화 작업
    - 재사용의 범위: 함수-객체 재사용(소스코드), 컴포넌트 재사용(인터페이스), 애플리케이션 재사용(통신)
    - 재사용의 유형
        1. 편의적 재사용 = 내부 재사용 + 외부 재사용
            - 프로젝트를 시작할때 재사용할 컴포넌트 있는지 찾아보고 재사용
            - 내부 재사용: 팀내에서 재사용 -> 추가적인 비용발생(계획된것이 X)
            - 외부 재사용: 서드파티(제3자기업)에서 만든거 재사용 -> 시간 고려(학습&활용 시간)
        2. 계획적 재사용: 컴포넌트를 차후에 재사용 가능하도록 전략적으로 설계
    - 사례
        - SW 라이브러리: 코드 재사용(필요 부분->라이브러리로 만들어서 사용), 변경 시 세부사항 조절 X, 시간과 비용이 든다(학습&활용)
        - 디자인 패턴: 비슷한 문제를 풀기 위한 범용적인 해법, 수정 가능(개념적이기 때문), 추상클래스+인터페이스 -> 재사용 가능
        - 프레임워크: 많은 SW를 재사용한다
    - 이점:개발 시간+비용 단축, 품질 향상, 생산성 향상, 실패위험 감소, 지식 공유, 문서 공유(시스템 코드, 명세, 설계 등)
    
* SW 모듈 응집도 
    - 응집도: 정보은닉의 개념 확장, 모듈은 하나의 기능을 수행하는 집적성으로 이 모듈 내부 구성원 간의 연관도이다
    - 응집도 특징: 함수 개수가 적음(기능을 줄여 다른 함수와 협력)
    - 응집도 유형: 기능적 -> 순차적 -> 통신적 -> 절차적 -> 시간적 -> 논리적 -> 우연적 [응집도 낮음 - 응집도 높음]
* SW 모듈 결합도
    - 결합도 특징: 인터페이스 복잡성에 의존적(자료 전달), 낮은 결합도(복잡성 감소), 리플 효과 최소화해야함(에러 발생시 오류 전파)
    - 결합도 유형: 자료 -> 스탬프 -> 제어 -> 외부 -> 공통(공동) -> 내용 [결합도 낮음 - 결합도 높음]
* SW 모듈화
    - 모듈화 원리: 정보 은폐, 자료 추상화, 모듈의 독립성(낮은 결합도, 높은 응집도), 분할과 지배
    - 모듈화의 종류
    
                1. 설계 측면
                    모듈 = 라이브러리 형태로 사용(관련있는 기능 모아 한 라이브러로 사용)
                    컴포넌트 = 인터페이스에 의해 조직을 수행할 수 있는 모듈 단위(바이너리 형태의 재사용 가능한 모델)
                    서비스 = 컴포넌트보다 Loosely-coupled한 형태의 기능 제공하는모듈 단위
                2. 구현 측면
                    매크로(macro) = 반복되는 부분을 특정 이름을 부여하고 이름을 호출하여 실행, 전처리기가 코드를 대체해 놓는다
                    함수 = 특정 작업을하고 다른 코드에 비해 독립적인 모듈
                    인라인: 매크로랑 같은데, 컴파일러가 코드 복사
* 공통 모듈 수행
    1. 작성해야 할 공통 모듈 확인(공통 모듈의 상세 설계=**공통 모듈 관리 대장** 참고)
        - 공통 모듈 확인 -> 공통 모듈의 기능 확인 -> 공통 모듈 관리 대장의 ID와 일치하는 프로그램 설계서의 프로그램 ID을 확인
    2. 공통 모듈 구현(공통 모듈 관리대장 참고(공통 모듈의 상세설계))
        - DTO/VO 구현(공통 코드 조회를 위해 변수들을 정의)
            -> SQL 작성(공통 코드 조회를 위해 SQL 쿼리문 구현)
                -> DAO(데이터 접근 객체) 구현 (DAO에서는 SQL문을 구현한 것에서 해당 ID값을 호출하여 데이터 조회/조작함)
                    -> 서비스 클래스 구현(스탬프 결합도 수준(결합도 낮음)의 서비스 구현)
                        -> 컨트롤러 클래스 구현(시스템 외/내부에서 사용할 수 있도록 함 REST API처럼)
* 공통 모듈 테스트
    * 테스트 프로세스 = 계획/제어 -> 분석/설계 -> 구현/실행 -> 평가 -> 완료
    - 공통 모듈 테스트 수행
        1. 단위 테스트 케이스 작성을 위해 참조 문서 수집 (공통 모듈 관리 대장 + 요구사항 정의서/명세서 + 분석 및 설계 문서 수집)
        2. 단위 테스트 케이스 작성 (방식 결정 -> 범위 결정 -> 방식,범위에 따른 테스트 케이스 작성)
        3. 작성된 단위 테스트 케이스 내부 검토( 공통모듈의 활용성, 영향도 체크)
        4. 작성된 단위 테스트 케이스를 고객에게 승인 획득
        5. 테스트를 명세하기 위한 테스트 도구 설정
        6. 테스트 결과 명세 (성공/실패 결과 기록)
-----------
##### 서버 프로그램 구현하기
* 업무 프로세스 확인
    - 프로세스 = 개인이나 조직이한가지 이상의 정보 자원의 입력을 통해 가치 있는 산출물을 제공하는 모든 관련 활동들의 집합
        * 프로세스 모델: 공급자 -입력-> 프로세스 -출력-> 고객
    - 프로세스 구성요소: 책임자(설계,유지), 프로세스 맵(상하위 프로세스 도시확), 프로세스 TASK, 프로세스 성과 지표(고객입장), 프로세스 조직, 경영자의 리더십
        * 프로세스 맵: 상위 프로세스 -> 하위프로세스로의 흐름 체계 도식화
            - 종류: 구조적 분석 기법에서의 자료 흐름도, 객체지향 분석 기법의 다이어그램
    - 업무 프로세스 수행하기
        1. 상세 설계를 기반으로 담당 업무 확인: 프로그램 관리 대장을 통해 업무 프로그램 확인, 프로그램 설계서+프로세스 맵 확인
        2. 세부 업무 프로세스 확인: 프로그램 관리 대장의 ID와 일치하는 프로그램 설계서 산출물의 ID를 확인-> 화면 설계서 확인 -> 화면 레이아웃 확인

* 서버 프로그램 구현
    + 프레임 워크
        - 프레임워크 정의: 코드 라이브러리, 애플리케이션 인터페이스, 설정 정보 등의 집합으로 재사용이 가능하도록 기본 뼈대 제공
        - 프레임워크 특징: 모듈화(인터페이스의 캡슐화 이용), 재사용성, 확장성(다형성), 제어의 역흐름(다형성을 통해 어플리케이션이 확장한 메소드를 호출함으로써 제어가 프레임 워크->어플리케이션으로 흐름)
    + SW 보안
        - 보안 가이드: 시큐어 코딩(입력 데이터 검증 및 표현, 보안 기능, 시간 및 상태, 에러처리 ,코드오류, 캡슐화, API 오용)
        - 보안 취약성 식별
            - 시스템의 물리적 환경 취약점: 직원, 관리, HW, SW, 통신장비 등
            - SW 취약점
            
                    1. 메모리 보안 침입 - 버퍼 오버 플로
                                       - 허상 포인터(적절한 타입의 유효한 객체를 가리키고 있지 않음)
                                       
                    2. 입력 확인 오류   - 포맷 스트링 버그(검사X입력 -> 포맷 스트링 파라미터로 사용)
                                       - SQL 삽입(코드 인젝션)
                                       - 코드 인젝션(유효하지 않은 데이터 실행_
                                       - 이메일 인젝션(메일 헤더를 부정확하게 추가)
                                       - 디렉터리 접근 공객
                                       - WAS의 사이트 간 스크립팅
                                       - HTTP 헤더 인젝션(리스폰스 헤더 필드에 개행문자 삽입)
                                       - HTTP 응답 스플리팅(개행문자를 이용해 첫번째 응답 종료->두번쨰 응답 악의적인 코드 주입)
                                       
                    3. 경쟁 상태       - Time-of-check-to-time-of-use 버그
                                       - 심볼릭 링크 경쟁
    + API
        - API: 응용프로그램에서 사용할수 있도록 OS, 프로그래밍 언어가 제공하는 기능 제어하는 인터페이스(ex_파일, 창, 화상, 문자 등)
            + 절차적 언어의 API: API는 트겆ㅇ 작업을 수행할 함수들의 집합
            + Windows API: 마이크로소프트 OS들이 사용하는 API
            + 단일 유닉스 규격(SUS): 유닉스 OS를 사용하기 위해 지켜야하는 표준 규격의 총칭
            + JAVA API: 클래스 라이브러리(JAVA 쉽게 이용)->계층 구조로 설계되어 있음
            + 웹 API: 다른 서비스에 요청 보내고 응답 받기위해 정의된 명세
    + 서버 프로그램 구현 수행하기
        * 세부 업무 프로세스를 기반으로 업무 프로그램 구현(서버영역+화면역역 구현)
        
            DTO/VO 정의 -> DATA 준비(업무 프로그램 구현 위해) -> SQL 작성-> DAO 구현->서비스 클래스 구현->시큐어 코딩 가이드->컨트롤러 클래스 구현
 
* 서버 프로그램 테스트
    + SW 테스트 원칙
        1. 개발자가 자신이 개발한 프로그램 및 소스코드 테스팅하면 안된다
        2. 효율적인 결함 제거 법칙 사용(낚시의 법칙(특정 기능, 모듈, 라이브러리에서 많이 발견), 파레토의 법칙(전체 결함 80%는 SW의 전체 기능 중 20%에 집중)
        3. 완벽한 SW 테스팅 불가
        4. 테스트는 계획 단계부터 해야한다
        5. 살충제 패러독스(동일한 테스트 케이스 X -> 주기적으로 테스트 케이스 리뷰 및 개선)
        6. 오류-부재의 궤변(사용자의 요구사항을 만족시키지 못함)
     + 테스트 수행하기
        공통 모듈 테스트와 동일함
 -------------
##### 배치프로그램 구현
* 배치 프로그램 구현
    - 배치 프로그램 = 사용자와의 상호작용 없이 일련의 작업들을 작업 단위로 묶어 정기적으로 반복 수행하거나 정해진 규칙에 따라 일괄 처리
    - 배치 프로그램 필수 요소 = 대용량 데이터 + 자동화 + 견고함 + 안정성 + 성능
    - 배치 스케줄러 = 일괄처리를 위해 주기적으로 발생하거나 반복적으로 발생하는 작업을 지원하는 도구
        * 종류
            
                -스프링 배치 : 스프링 프레임워크 기반, 자체 제공 컴포넌트, 견고함과 안정성
                -Quartz 스케줄러: 스프링 프레임워크에 플러그인되어 수행하는 JOB과 실행 스케줄을 정의하는 Trigger를 분리하여 유연성 제공하는 오픈소스 스케줄러
    - 배치프로그램 수행하기
        1. 애플리케이션 설계 기반으로 배치 프로그램 확인
            - 프로그램 관리 대장 확인 -> 배치 설계서 확인
        2. 애플리케이션 설계 기반으로 배치 프로그램 구현
        
            SQL 작성->DTO/VO정의->DAO작성->스케줄러 클래스 작성
    - 배치프로그램 테스트
        * 디버그: 컴퓨터 프로그램의 논리적인 오류 찾아냄
        * 디버거: 디버그를 돕는 도구. 코드를 단계적으로 실행하여 저장 값 확인(중단점(Break Pointer)를 설정하여)
        - 수행하기
            1. 배치프로그램 주기 변경(테스트가 가능한 주기로)
            2. 배치 프로그램 디버깅하여 정상 작동하는 확인
            3. 배치 프로그램의 로그 확인
            4. 목적 테이블에서 정상적으로 배치 프로그램이 실행되었는지 확인
            5. 배치 프로그램이 정상적으로 실행되지 않았을 경우 오류 확인
                           
